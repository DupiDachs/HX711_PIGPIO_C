#include <stdio.h>
#include <pigpio.h>
#include <unistd.h>
#include <time.h>

/* -----------------------------------------------------------------------

HX711 simplified C port of python pigpio version
see: http://abyz.me.uk/rpi/pigpio/examples.html

build it like this:
gcc -Wall -pthread -o HX711 HX711.cpp -lpigpio -lrt
   ----------------------------------------------------------------------- */

/* user data ############################################################# 
   - specify as required from your setup */

#define DATA  5 // GPIO 5 for data pin
#define CLOCK 6 // GPIO 6 for clock signal
#define GAIN  1 // gain of 128, channel A
#define RATE  1 // 80 samples per second, you need to connect pin 15
                // of the HX711 for this
#define DIVIDER 462 // divide readings of HX711 to obtain result in grams
#define OFFSET  448 // offset in grams for correct zero reading

/* ####################################################################### */

// set number of clock cycles depending on gain
#define DATA_CLKS 24
#if GAIN == 0
    #define X_CLK 27 // channel A gain 64
#elif GAIN == 1
    #define X_CLK 25 // channel A gain 128
#else
    #define X_CLK 26 // channel B gain 32
#endif

// set the timeout in us to filter spurious data
#if RATE == 1
    #define TIMEOUT_RATE 5000  // timeout for 80 samples per second
#else
    #define TIMEOUT_RATE 90000 // timeout for 10 samples per second
#endif

/* pigpio library resets tick count after ~72 min
   -> adjust timer accordingly to continue correct measurement */
#define TIMEOUT       4294967295
#define TIMEOUT_PREP  4294900000
#define TIMEOUT_PREP2      50000

// length of the pulses in us
#define PULSE_LEN 20

// discard first 5 readings
#define SETTLE_READINGS 5

// stub for interrupt callbacks
void callbackC(int pin, int level, uint32_t tick);
void callbackD(int pin, int level, uint32_t tick);

// counter for clock cycles
int clocks = 0;
// value read by the HX711
int value  = 0;
// single bit data at respective clock
int dataLevel = 0;
// counter to discard first readings
int skipReadings = SETTLE_READINGS;
// wave generated by pigpio
char wid;
// do we currently take a measurement?
// this is triggered by DATA going low for a longer time
bool inWave = false;
// timestamp at which the last reading was taken
int lastTick = 0;
// timestamp when the program started
time_t seconds;
double timestamp;
// flag to add offset to timestamp when timer of pigpio resets
bool offset = false;
// just some definitions for waveform
gpioPulse_t pulse[2];
char chain[7];

int main ()
{
   if (gpioInitialise()<0) return 1;
   seconds = time(NULL);
   timestamp = (double) seconds - gpioTick()/1000000 - 1.5;

   // initialize HX711
   gpioWrite(CLOCK, 1);
   sleep(1);
   gpioWrite(CLOCK, 0);
   
   // prepare GPIOs and waveform
   gpioSetMode(CLOCK, PI_OUTPUT);
   gpioSetMode(DATA , PI_INPUT);
   
   pulse[0].gpioOn = (1<<CLOCK);
   pulse[0].gpioOff = 0;
   pulse[0].usDelay = PULSE_LEN;

   pulse[1].gpioOn = 0;
   pulse[1].gpioOff = (1<<CLOCK);
   pulse[1].usDelay = PULSE_LEN;
   gpioWaveAddNew();
   gpioWaveAddGeneric(2, pulse);
   wid = gpioWaveCreate();
   
   chain[0] = 255;
   chain[1] = 0;
   chain[2] = wid;
   chain[3] = 255;
   chain[4] = 1;
   chain[5] = X_CLK;
   chain[6] = 0;
   
   // set callbacks for interrupts
   gpioSetAlertFunc(CLOCK, callbackC);
   gpioSetAlertFunc(DATA, callbackD);
   
   while (1)
   {
      // Everything is done within the interrupts. No need to do anything here ...
      sleep(500);
   }

   gpioTerminate();
}

// callback for CLOCK
void callbackC(int pin, int level, uint32_t tick)
{
    // tigger on falling edge
    if (!level) {
        clocks+=1;
        // when we are taking a reading (inWave) ...
        if (inWave && clocks <= DATA_CLKS) {
            value = (value << 1) + dataLevel;
            // at the end of a reading ...
            if (clocks == DATA_CLKS) {
                inWave = false;
                if (value & 0x800000) {
                    value |= ~0xffffff;
                }
                if (skipReadings <= 0) {
                    float valueF = (float)value/DIVIDER-OFFSET;
                    if (offset && tick < TIMEOUT_PREP2) {
                        timestamp = timestamp + (double)TIMEOUT/1000000;
                        offset = false;
                        lastTick = tick;
                    }
                    printf("%f,%f\n", timestamp + (double)tick/1000000, valueF);
                    fflush(stdout);
                } else {
                    skipReadings -=1;
                }
            }
        }
    }
}

// callback for DATA
void callbackD(int pin, int level, uint32_t tick)
{
   // read single bit
   dataLevel = level;
   
   // shall we start a new reading?
   if (!inWave && !level && (tick - lastTick) > TIMEOUT_RATE)
   {
       lastTick = tick;
       if (tick > TIMEOUT_PREP) {
           offset = true;
       }
       inWave = true;
       clocks = 0;
       value  = 0;
       gpioWaveChain(chain, 7);     // 7 chars in chain
   }
}
